#!/bin/bash
#set -x

###########################################
##
## Script to install and setup AutoBrew
##
###########################################

# Define variables
currentRelease=$(curl --silent "https://api.github.com/repos/Homebrew/brew/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
brewweburl="https://github.com/Homebrew/brew/releases/download/$currentRelease/Homebrew-$currentRelease.pkg"
swiftweburl="https://github.com/swiftDialog/swiftDialog/releases/download/v2.4.2/dialog-2.4.2-4755.pkg"
appname="AutoBrew"                                              # The name of our App deployment script
logandmetadir="/Library/Logs/Microsoft/Intune/Scripts/$appname" # The location of our logs and last updated data
autoUpdate="true"                                               # If true, application updates itself and we should not attempt to update

# Generated variables
tempdir=$(mktemp -d)
log="$logandmetadir/$appname.log"       # The location of the script log file
metafile="$logandmetadir/$appname.meta" # The location of our meta file (for updates)

# Functions
## function to delay script if the specified process is running
waitForProcess() {

    #################################################################################################################
    #################################################################################################################
    ##
    ##  Function to pause while a specified process is running
    ##
    ##  Functions used
    ##
    ##      None
    ##
    ##  Variables used
    ##
    ##      $1 = name of process to check for
    ##      $2 = length of delay (if missing, function to generate random delay between 10 and 60s)
    ##      $3 = true/false if = "true" terminate process, if "false" wait for it to close
    ##
    ###############################################################
    ###############################################################

    processName=$1
    fixedDelay=$2
    terminate=$3

    echo "$(date) | Waiting for other [$processName] processes to end"
    while ps aux | grep "$processName" | grep -v grep &>/dev/null; do

        if [[ $terminate == "true" ]]; then
            echo "$(date) | + [$appname] running, terminating [$processpath]..."
            pkill -f "$processName"
            return
        fi

        # If we've been passed a delay we should use it, otherwise we'll create a random delay each run
        if [[ ! $fixedDelay ]]; then
            delay=$(($RANDOM % 50 + 10))
        else
            delay=$fixedDelay
        fi

        echo "$(date) |  + Another instance of $processName is running, waiting [$delay] seconds"
        sleep $delay
    done

    echo "$(date) | No instances of [$processName] found, safe to proceed"

}

## Function to update the last modified date for this app
fetchLastModifiedDate() {

    #################################################################################################################
    #################################################################################################################
    ##
    ##  This function takes the following global variables and downloads the URL provided to a temporary location
    ##
    ##  Functions
    ##
    ##      none
    ##
    ##  Variables
    ##
    ##      $logandmetadir = Directory to read nand write meta data to
    ##      $metafile = Location of meta file (used to store last update time)
    ##      $brewweburl = URL of download location
    ##      $tempfile = location of temporary DMG file downloaded
    ##      $lastmodified = Generated by the function as the last-modified http header from the curl request
    ##
    ##  Notes
    ##
    ##      If called with "fetchLastModifiedDate update" the function will overwrite the current lastmodified date into metafile
    ##
    ###############################################################
    ###############################################################

    ## Check if the log directory has been created
    if [[ ! -d "$logandmetadir" ]]; then
        ## Creating Metadirectory
        echo "$(date) | Creating [$logandmetadir] to store metadata"
        mkdir -p "$logandmetadir"
    fi

    # generate the last modified date of the file we need to download
    lastmodified=$(curl -sIL "$brewweburl" | grep -i "last-modified" | awk '{$1=""; print $0}' | awk '{ sub(/^[ \t]+/, ""); print }' | tr -d '\r')

    if [[ $1 == "update" ]]; then
        echo "$(date) | Writing last modifieddate [$lastmodified] to [$metafile]"
        echo "$lastmodified" >"$metafile"
    fi

}

## Function to download the app files
function downloadApp() {

    #################################################################################################################
    #################################################################################################################
    ##
    ##  This function takes the following global variables and downloads the URL provided to a temporary location
    ##
    ##  Functions
    ##
    ##      waitForCurl (Pauses download until all other instances of Curl have finished)
    ##      downloadSize (Generates human readable size of the download for the logs)
    ##
    ##  Variables
    ##
    ##      $appname = Description of the App we are installing
    ##      $brewweburl = URL of download location
    ##      $tempfile = location of temporary DMG file downloaded
    ##
    ###############################################################
    ###############################################################

    echo "$(date) | Starting downlading of [$appname]"

    # wait for other downloads to complete
    waitForProcess "curl -f"

    #download the file
    echo "$(date) | Downloading $appname"

    cd "$tempdir"
    curl -f -s --connect-timeout 30 --retry 5 --retry-delay 60 -L -J -O "$brewweburl"
    if [ $? == 0 ]; then

        # We have downloaded a file, we need to know what the file is called and what type of file it is
        tempSearchPath="$tempdir/*"
        for f in $tempSearchPath; do
            tempfile=$f
        done

        case $tempfile in

        *.pkg | *.PKG)
            packageType="PKG"
            ;;

        *.zip | *.ZIP)
            packageType="ZIP"
            ;;

        *.dmg | *.DMG)
            packageType="DMG"
            ;;

        *)
            # We can't tell what this is by the file name, lets look at the metadata
            echo "$(date) | Unknown file type [$f], analysing metadata"
            metadata=$(file "$tempfile")
            if [[ "$metadata" == *"Zip archive data"* ]]; then
                packageType="ZIP"
                mv "$tempfile" "$tempdir/install.zip"
                tempfile="$tempdir/install.zip"
            fi

            if [[ "$metadata" == *"xar archive"* ]]; then
                packageType="PKG"
                mv "$tempfile" "$tempdir/install.pkg"
                tempfile="$tempdir/install.pkg"
            fi

            if [[ "$metadata" == *"bzip2 compressed data"* ]] || [[ "$metadata" == *"zlib compressed data"* ]]; then
                packageType="DMG"
                mv "$tempfile" "$tempdir/install.dmg"
                tempfile="$tempdir/install.dmg"
            fi

            ;;
        esac

        if [[ ! $packageType ]]; then
            echo "Failed to determine temp file type [$metadata]"
            rm -rf "$tempdir"
        else
            echo "$(date) | Downloaded [$app] to [$tempfile]"
            echo "$(date) | Detected install type as [$packageType]"
        fi

    else

        echo "$(date) | Failure to download [$brewweburl] to [$tempfile]"
        exit 1
    fi

}

## Function to check if we need to update or not
function updateCheck() {

    #################################################################################################################
    #################################################################################################################
    ##
    ##  This function takes the following dependencies and variables and exits if no update is required
    ##
    ##  Functions
    ##
    ##      fetchLastModifiedDate
    ##
    ##  Variables
    ##
    ##      $appname = Description of the App we are installing
    ##      $tempfile = location of temporary DMG file downloaded
    ##      $volume = name of volume mount point
    ##      $app = name of Application directory under /Applications
    ##
    ###############################################################
    ###############################################################

    echo "$(date) | Checking if we need to install or update [$appname]"

    ## Is the app already installed?
    if [ -d "/Applications/$app" ]; then

        # App is installed, if it's updates are handled by MAU we should quietly exit
        if [[ $autoUpdate == "true" ]]; then
            echo "$(date) | [$appname] is already installed and handles updates itself, exiting"
            exit 0
        fi

        # App is already installed, we need to determine if it requires updating or not
        echo "$(date) | [$appname] already installed, let's see if we need to update"
        fetchLastModifiedDate

        ## Did we store the last modified date last time we installed/updated?
        if [[ -d "$logandmetadir" ]]; then

            if [ -f "$metafile" ]; then
                previouslastmodifieddate=$(cat "$metafile")
                if [[ "$previouslastmodifieddate" != "$lastmodified" ]]; then
                    echo "$(date) | Update found, previous [$previouslastmodifieddate] and current [$lastmodified]"
                    update="update"
                else
                    echo "$(date) | No update between previous [$previouslastmodifieddate] and current [$lastmodified]"
                    echo "$(date) | Exiting, nothing to do"
                    exit 0
                fi
            else
                echo "$(date) | Meta file [$metafile] not found"
                echo "$(date) | Unable to determine if update required, updating [$appname] anyway"

            fi

        fi

    else
        echo "$(date) | [$appname] not installed, need to download and install"
    fi

}

## Install PKG Function
function installPKG() {

    #################################################################################################################
    #################################################################################################################
    ##
    ##  This function takes the following global variables and installs the PKG file
    ##
    ##  Functions
    ##
    ##      fetchLastModifiedDate (Called with update flag which causes the function to write the new lastmodified date to the metadata file)
    ##
    ##  Variables
    ##
    ##      $appname = Description of the App we are installing
    ##      $tempfile = location of temporary DMG file downloaded
    ##      $volume = name of volume mount point
    ##      $app = name of Application directory under /Applications
    ##
    ###############################################################
    ###############################################################

    echo "$(date) | Installing $appname"

    installer -pkg "$tempfile" -target /Applications

    # Checking if the app was installed successfully
    if [ "$?" = "0" ]; then

        echo "$(date) | $appname Installed"
        echo "$(date) | Cleaning Up"
        rm -rf "$tempdir"

        echo "$(date) | Application [$appname] succesfully installed"
        fetchLastModifiedDate update
    else

        echo "$(date) | Failed to install $appname"
        rm -rf "$tempdir"
    fi

}

## Function to start logging
function startLog() {

    ###################################################
    ###################################################
    ##
    ##  start logging - Output to log file and STDOUT
    ##
    ####################
    ####################

    if [[ ! -d "$logandmetadir" ]]; then
        ## Creating Metadirectory
        echo "$(date) | Creating [$logandmetadir] to store logs"
        mkdir -p "$logandmetadir"
    fi

    exec &> >(tee -a "$log")

}

## Function to delay until the user has finished setup assistant.
waitForDesktop() {
    until ps aux | grep /System/Library/CoreServices/Dock.app/Contents/MacOS/Dock | grep -v grep &>/dev/null; do
        delay=$(($RANDOM % 50 + 10))
        echo "$(date) |  + Dock not running, waiting [$delay] seconds"
        sleep $delay
    done
    echo "$(date) | Dock is here, lets carry on"
}

# Begin Script Body
## Initiate logging
startLog

echo ""
echo "##############################################################"
echo "# $(date) | Logging install of [$appname] to [$log]"
echo "############################################################"
echo ""

## Wait for Desktop
waitForDesktop

## Swift Dialog install
## Note, Rosetta detection code from https://derflounder.wordpress.com/2020/11/17/installing-rosetta-2-on-apple-silicon-macs/
OLDIFS=$IFS
IFS='.' read osvers_major osvers_minor osvers_dot_version <<<"$(/usr/bin/sw_vers -productVersion)"
IFS=$OLDIFS

if [[ ${osvers_major} -ge 11 ]]; then

    # Check to see if the Mac needs Rosetta installed by testing the processor
    processor=$(/usr/sbin/sysctl -n machdep.cpu.brand_string | grep -o "Intel")

    if [[ -n "$processor" ]]; then
        echo "$(date) | $processor processor installed. No need to install Rosetta."
    else
        # Check for Rosetta "oahd" process. If not found,
        # perform a non-interactive install of Rosetta.
        if /usr/bin/pgrep oahd >/dev/null 2>&1; then
            echo "$(date) | Rosetta is already installed and running. Nothing to do."
        else
            /usr/sbin/softwareupdate --install-rosetta --agree-to-license
        fi
    fi
else
    echo "$(date) | Mac is running macOS $osvers_major.$osvers_minor.$osvers_dot_version."
    echo "$(date) | No need to install Rosetta on this version of macOS."
fi


## Aria2c installation
ARIA2="/usr/local/aria2/bin/aria2c"
aria2Url="https://github.com/aria2/aria2/releases/download/release-1.35.0/aria2-1.35.0-osx-darwin.dmg"
if [[ -f $ARIA2 ]]; then
    echo "$(date) | Aria2 already installed, nothing to do"
else
    echo "$(date) | Aria2 missing, lets download and install"
    filename=$(basename "$aria2Url")
    output="$tempdir/$filename"
    #curl -L -o "$output" "$aria2Url"
    curl -f -s --connect-timeout 30 --retry 5 --retry-delay 60 -L -o "$output" "$aria2Url"
    if [ $? -ne 0 ]; then
        echo "$(date) | Aria download failed"
        echo "$(date) | Output: [$output]"
        echo "$(date) | URL [$aria2Url]"
        exit 1
    else
        echo "$(date) | Downloaded aria2"
    fi

    # Mount aria2 DMG
    mountpoint="$tempdir/aria2"
    echo "$(date) | Mounting Aria DMG..."
    hdiutil attach -quiet -nobrowse -mountpoint "$mountpoint" "$output"
    if [ $? -ne 0 ]; then
        echo "$(date) | Aria mount failed"
        echo "$(date) | Mount: [$mountpoint]"
        echo "$(date) | Temp File [$output]"
        exit 1
    else
        echo "$(date) | Mounted DMG"
    fi

    # Install aria2 PKG from inside the DMG
    sudo installer -pkg "$mountpoint/aria2.pkg" -target /
    if [ $? -ne 0 ]; then
        echo "$(date) | Install failed"
        echo "$(date) | PKG: [$mountpoint/aria2.pkg]"
        exit 1
    else
        echo "$(date) | Aria2 installed"
        hdiutil detach -quiet "$mountpoint"
    fi
    rm -rf "$output"
fi

## Start Download of Swift Dialog
echo "$(date) | Downloading Swift Dialog [$swiftweburl]"
cd "$tempdir"
#curl -f -s --connect-timeout 30 --retry 5 --retry-delay 60 --compressed -L -J -o "$tempdir/swiftdialog.pkg" "$weburl"
$ARIA2 -q -x16 -s16 -d "$tempdir" -o "swiftdialog.pkg" "$swiftweburl" --download-result=hide --summary-interval=0

# Installing Swift Dialog
installer -pkg "$tempdir/swiftdialog.pkg" -target /

## Install X-Code Command line tools
echo "$(date) | Starting Installation of xcode pre-reqs"

# Only run if the tools are not installed yet
xcode-select -p &>/dev/null
if [ $? -ne 0 ]; then
    echo "$(date) | Command Line Tools for Xcode not found. Installing from softwareupdate"
    # This temporary file prompts the 'softwareupdate' utility to list the Command Line Tools
    touch /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress
    PROD=$(softwareupdate -l | grep "\*.*Command Line" | tail -n 1 | sed 's/^[^C]* //')
    softwareupdate -i "$PROD" --verbose
else
    echo "$(date) | Command Line Tools for Xcode have been installed."
fi

## Download Brew
downloadApp

## Install Brew
installPKG

## Install Brew Cask Upgrade
echo "$(date) | Installing Brew Cask Upgrade"
/opt/homebrew/bin/brew tap buo/cask-upgrade
brewtaps=$(/opt/homebrew/bin/brew tap)
if [[ $brewtaps == *'buo/cask-upgrade'* ]]; then
    echo "$(date) | Brew Cask Upgrade installed"
    exit 0
else
    echo "$(date) | Brew Cask Upgrade not installed"
    exit 1
fi
